# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_rxtransform.ipynb (unless otherwise specified).

__all__ = ['Subscription']

# Cell
from fastai2.basics import *
from .core import *

# Cell
def _maintain_labels(old, new):
    if hasattr(old, 'labels'): new = add_attr(new, 'labels', old.labels)
    return new

# Cell
def _hash_fn(o): return o.__name__

# Cell
@patch
def __new__(cls:Transform, *args, **kwargs):
    obj = super(Transform, cls).__new__(cls)
    obj.listeners = OrderedDict()
    obj.pre_broad = dict()
    return obj

# Cell
_old_do_call = Transform._do_call
@patch
def _do_call(self:Transform, f, x, **kwargs):
    res = _maintain_labels(x, _old_do_call(self, f, x, **kwargs))
    if f[type(x)] is not None: # Checks for type dispatch
        self._pres = {k: v(res) for k,v in self.pre_broad.items()}
        res = self.broadcast(res)
    return res

# Cell
@patch
def broadcast(self:Transform, x):
    for f,pre in self.listeners.values():
        res = f(x, *[self._pres[_hash_fn(o)] for o in pre])
        if res is not None: x = res
    return x

# Cell
class Subscription:
    def __init__(self, f, cancel):
        self.f,self.cancel,self.sub = f,cancel,None

    @property
    def __name__(self): return self.f.__name__

    def __call__(self, *args, **kwargs):
        if self.sub is not None: self.sub(self.__name__)
        self.sub = None
        return self.f(*args, **kwargs)

    def listen_one(self, f): self.sub = f

    def cancel(self):
        self.cancel()
        self.sub = None

# Cell
@patch
def listen(self:Transform, *pre):
    for o in pre: self.pre_broad[_hash_fn(o)] = o
    def _inner(f):
        f = Subscription(f, lambda: self.listeners.pop(f_hash))
        f_hash = _hash_fn(f)
        self.listeners[f_hash] = (f, pre)
        return f
    return _inner