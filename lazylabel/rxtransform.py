# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_rxtransform.ipynb (unless otherwise specified).

__all__ = ['Subscription']

# Cell
from fastai2.basics import *
from .core import *

# Cell
def _maintain_labels(old, new):
    if isinstance(new, tuple): return new
    return add_attr(new, 'labels', getattr(old, 'labels', []))

# Cell
def _hash_fn(o): return o.__name__

# Cell
@patch
def __new__(cls:Transform, *args, **kwargs):
    obj = super(Transform, cls).__new__(cls)
    obj.listeners = OrderedDict()
    obj.pre_broad = dict()
    return obj

# Cell
_old_do_call = Transform._do_call
@patch
def _do_call(self:Transform, f, x, **kwargs):
    res = _maintain_labels(x, _old_do_call(self, f, x, **kwargs))
    if f[type(x)] is not None: # Checks for type dispatch
        self._pres = {k: v(x) for k,v in self.pre_broad.items()}
        self.broadcast(res)
    return res

# Cell
@patch
def broadcast(self:Transform, x):
    for f,pre in self.listeners.values(): f(x, *[self._pres[_hash_fn(o)] for o in pre])

# Cell
class Subscription:
    def __init__(self, f, cancel):
        self.f,self.cancel,self.sub = f,cancel,None

    @property
    def __name__(self): return self.f.__name__

    def __call__(self, *args, **kwargs):
        if self.sub is not None: self.sub(self.__name__)
        self.sub = None
        return self.f(*args, **kwargs)

    def listen_one(self, f): self.sub = f

    def cancel(self):
        self.cancel()
        self.sub = None

# Cell
# from functools import wraps
# def subscription(f, cancel):
#     sub = None
#     def _cancel(): cancel(), subs.clear()
#     f.cancel = _cancel
#     f.listen_one = lambda o: sub =
#     @wraps(f)
#     def _inner(*args, **kwargs):
#         for sub in subs: sub(f.__name__)
#         subs.clear()
#         return f(*args, **kwargs)
#     return _inner

# Cell
@patch
def listen(self:Transform, *pre):
    for o in pre: self.pre_broad[_hash_fn(o)] = o
    def _inner(f):
        f = Subscription(f, lambda: self.listeners.pop(f_hash))
        f_hash = _hash_fn(f)
        self.listeners[f_hash] = (f, pre)
        return f
    return _inner